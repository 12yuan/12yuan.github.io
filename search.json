[{"title":"Redis","url":"https://12yuan.github.io/2020/12/28/史上最便捷搭建Zookeeper服务器的方法/","content":"史上最便捷搭建Zookeeper服务器的方法[TOC]\n什么是 ZooKeeperZooKeeper 是 Apache 的一个顶级项目，为分布式应用提供高效、高可用的分布式协调服务，提供了诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知和分布式锁等分布式基础服务。由于 ZooKeeper 便捷的使用方式、卓越的性能和良好的稳定性，被广泛地应用于诸如 Hadoop、HBase、Kafka 和 Dubbo 等大型分布式系统中。\nZookeeper 有三种运行模式：单机模式、伪集群模式和集群模式。\n\n单机模式：这种模式一般适用于开发测试环境，一方面我们没有那么多机器资源，另外就是平时的开发调试并不需要极好的稳定性。\n集群模式：一个 ZooKeeper 集群通常由一组机器组成，一般 3 台以上就可以组成一个可用的 ZooKeeper 集群了。组成 ZooKeeper 集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都会互相保持通信。\n伪集群模式：这是一种特殊的集群模式，即集群的所有服务器都部署在一台机器上。当你手头上有一台比较好的机器，如果作为单机模式进行部署，就会浪费资源，这种情况下，ZooKeeper 允许你在一台机器上通过启动不同的端口来启动多个 ZooKeeper 服务实例，以此来以集群的特性来对外服务。\n\nZooKeeper 的相关知识Zookeeper 中的角色：\n领导者（leader）：负责进行投票的发起和决议，更新系统状态。\n跟随者（follower）：用于接收客户端请求并给客户端返回结果，在选主过程中进行投票。\n观察者（observer）：可以接受客户端连接，将写请求转发给 leader，但是observer 不参加投票的过程，只是为了扩展系统，提高读取的速度。\n\n\nZookeeper 的数据模型\n\n层次化的目录结构，命名符合常规文件系统规范，类似于 Linux。\n每个节点在 Zookeeper 中叫做 Znode，并且其有一个唯一的路径标识。\n节点 Znode 可以包含数据和子节点，但是 EPHEMERAL 类型的节点不能有子节点。\nZnode 中的数据可以有多个版本，比如某一个路径下存有多个数据版本，那么查询这个路径下的数据就需要带上版本。\n客户端应用可以在节点上设置监视器。\n节点不支持部分读写，而是一次性完整读写。\n\n\nZooKeeper 的节点特性ZooKeeper 节点是生命周期的，这取决于节点的类型。在 ZooKeeper 中，节点根据持续时间可以分为持久节点（PERSISTENT）、临时节点（EPHEMERAL），根据是否有序可以分为顺序节点（SEQUENTIAL）、和无序节点（默认是无序的）。\n持久节点一旦被创建，除非主动移除，不然一直会保存在 Zookeeper 中（不会因为创建该节点的客户端的会话失效而消失）。\nZookeeper 的应用场景ZooKeeper 是一个高可用的分布式数据管理与系统协调框架。基于对 Paxos 算法的实现，使该框架保证了分布式环境中数据的强一致性，也正是基于这样的特性，使得 ZooKeeper 解决很多分布式问题。\n值得注意的是，ZooKeeper 并非天生就是为这些应用场景设计的，都是后来众多开发者根据其框架的特性，利用其提供的一系列 API 接口（或者称为原语集），摸索出来的典型使用方法。\n数据发布与订阅（配置中心）发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到 ZooKeeper 节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。\n应用中用到的一些配置信息放到 ZooKeeper 上进行集中管理。这类场景通常是这样：应用在启动的时候会主动来获取一次配置，同时在节点上注册一个 Watcher。这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。\n分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在 ZooKeeper 的一些指定节点，供各个客户端订阅使用。\n分布式日志收集系统\n这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用来分配收集任务单元，因此需要在 ZooKeeper 上创建一个以应用名作为 path 的节点 P，并将这个应用的所有机器 IP，以子节点的形式注册到节点 P 上。这样一来就能够实现机器变动的时候，能够实时通知到收集器调整任务分配。\n系统中有些信息需要动态获取，并且还会存在人工手动去修改这个信息的发问。通常是暴露出接口，例如 JMX 接口，来获取一些运行时的信息。引入 ZooKeeper 之后，就不用自己实现一套方案了，只要将这些信息存放到指定的 ZooKeeper 节点上即可。\n注意：在上面提到的应用场景中，有个默认前提——数据量很小，但是数据更新可能会比较快的场景。\n负载均衡这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。\n命名服务（Naming Service）命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称它们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用 ZooKeeper 提供的创建节点的 API，能够很容易创建一个全局唯一的path，这个 path 就可以作为一个名字。\n阿里巴巴集团开源的分布式服务框架 Dubbo 中使用 ZooKeeper 来作为其命名服务，维护全局的服务地址列表。在 Dubbo 的实现中：\n\n服务提供者在启动的时候，向 ZooKeeper 上的指定节点 /dubbo/${serviceName}/providers 目录下写入自己的 URL 地址，这个操作就完成了服务的发布。\n服务消费者启动的时候，订阅 /dubbo/${serviceName}/providers 目录下的提供者 URL 地址， 并向 /dubbo/${serviceName} /consumers 目录下写入自己的 URL 地址。\n\n注意：所有向 ZooKeeper 上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。\n另外，Dubbo 还有针对服务粒度的监控。方法是订阅 /dubbo/${serviceName} 目录下所有提供者和消费者的信息。\n分布式通知/协调ZooKeeper 中特有 Watcher 注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。使用方法通常是不同系统都对 ZooKeeper 上同一个 Znode 进行注册，监听 Znode 的变化（包括 Znode 本身内容及子节点的），其中一个系统 Update 了 Znode，那么另一个系统能够收到通知，并作出相应处理。\n另一种心跳检测机制：检测系统和被检测系统之间并不直接关联起来，而是通过 ZooKeeper 上某个节点关联，大大减少系统耦合。\n另一种系统调度模式：某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了 ZooKeeper 上某些节点的状态，而 ZooKeeper 就把这些变化通知给它们注册 Watcher 的客户端，即推送系统。于是，作出相应的推送任务。\n另一种工作汇报模式：一些类似于任务分发系统。子任务启动后，到 ZooKeeper 来注册一个临时节点，并且定时将自己的进度进行汇报（将进度写回这个临时节点）。这样任务管理者就能够实时知道任务进度。\n分布式锁分布式锁主要得益于 ZooKeeper 为我们保证了数据的强一致性。锁服务可以分为两类：一类是保持独占，另一类是控制时序。\n所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把 ZooKeeper 上的一个 Znode 看作是一把锁，通过 create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。\n控制时序，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL 来指定）。ZooKeeper 的父节点（/distribute_lock）维持一份 sequence，保证子节点创建的时序性，从而也形成了每个客户端的全局时序。\n\n由于同一节点下子节点名称不能相同，所以只要在某个节点下创建 Znode，创建成功即表明加锁成功。注册监听器监听此 Znode，只要删除此 Znode 就通知其他客户端来加锁。\n创建临时顺序节点：在某个节点下创建节点，来一个请求则创建一个节点，由于是顺序的，所以序号最小的获得锁，当释放锁时，通知下一序号获得锁。\n\n分布式队列队列方面，简单来说有两种：一种是常规的先进先出队列，另一种是等队列的队员聚齐以后才按照顺序执行。对于第一种的队列和上面讲的分布式锁服务中控制时序的场景基本原理一致，这里就不赘述了。\n第二种队列其实是在 FIFO 队列的基础上作了一个增强。通常可以在 /queue 这个 Znode 下预先建立一个 /queue/num 节点，并且赋值为 n（或者直接给 /queue 赋值 n）表示队列大小。之后每次有队列成员加入后，就判断下是否已经到达队列大小，决定是否可以开始执行了。\n这种用法的典型场景是：分布式环境中，一个大任务 Task A，需要在很多子任务完成（或条件就绪）情况下才能进行。这个时候，凡是其中一个子任务完成（就绪），那么就去 /taskList 下建立自己的临时时序节点（CreateMode.EPHEMERAL_SEQUENTIAL）。当 /taskList 发现自己下面的子节点满足指定个数，就可以进行下一步按序进行处理了。\n使用 dokcer-compose 搭建集群\n上面我们介绍了关于 ZooKeeper 有这么多的应用场景，那么接下来就先学习如何搭建 ZooKeeper 集群然后再进行实战上面的应用场景。\n文件的目录结构如下：\n├── docker-compose.yml\n\n\n\n编写 docker-compose.yml 文件\ndocker-compose.yml 文件内容如下：\nversion: &#39;3.4&#39;services:  \tzoo1:    \t\timage: zookeeper    \t\trestart: always    \t\thostname: zoo1    \t\tports:      \t\t\t- 2181:2181    \t\tenvironment:      \t\t\tZOO_MY_ID: 1      \t\t\tZOO_SERVERS: server.1&#x3D;0.0.0.0:2888:3888;2181 server.2&#x3D;zoo2:2888:3888;2181 server.3&#x3D;zoo3:2888:3888;2181    zoo2:      \timage: zookeeper      \trestart: always      \thostname: zoo2      \tports:        \t\t- 2182:2181      \tenvironment:        \t\tZOO_MY_ID: 2        \t\tZOO_SERVERS: server.1&#x3D;zoo1:2888:3888;2181 server.2&#x3D;0.0.0.0:2888:3888;2181 server.3&#x3D;zoo3:2888:3888;2181    zoo3:      \timage: zookeeper      \trestart: always       hostname: zoo3        ports:          \t- 2183:2181        environment:          \tZOO_MY_ID: 3          \tZOO_SERVERS: server.1&#x3D;zoo1:2888:3888;2181 server.2&#x3D;zoo2:2888:3888;2181 server.3&#x3D;0.0.0.0:2888:3888;2181\n\n\n\n在这个配置文件中，Docker 运行了 3 个 Zookeeper 镜像，通过 ports 字段分别将本地的 2181, 2182, 2183 端口绑定到对应容器的 2181 端口上。\nZOO_MY_ID 和 ZOO_SERVERS 是搭建 Zookeeper 集群需要的两个环境变量。ZOO_MY_ID 标识服务的 id，为 1-255 之间的整数，必须在集群中唯一。ZOO_SERVERS 是集群中的主机列表。\n在 docker-compose.yml 所在目录下执行 docker-compose up，可以看到启动的日志。\n连接 ZooKeeper将集群启动起来以后我们可以连接 ZooKeeper 对其进行节点的相关操作。\n\n首先需要下载 ZooKeeper。\n将其解压。\n进入其 conf/ 目录，将 zoo_sample .cfg 改成 zoo.cfg。\n\n配置文件说明\n# The number of milliseconds of each tick# tickTime：CS通信心跳数# Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。tickTime以毫秒为单位。tickTime&#x3D;2000# The number of ticks that the initial# synchronization phase can take# initLimit：LF初始通信时限# 集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量）。initLimit&#x3D;5# The number of ticks that can pass between# sending a request and getting an acknowledgement# syncLimit：LF同步通信时限# 集群中的follower服务器与leader服务器之间请求和应答之间能容忍的最多心跳数（tickTime的数量）。syncLimit&#x3D;2# the directory where the snapshot is stored.# do not use &#x2F;tmp for storage, &#x2F;tmp here is just# example sakes.# dataDir：数据文件目录# Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。dataDir&#x3D;&#x2F;data&#x2F;soft&#x2F;zookeeper-3.4.12&#x2F;data# dataLogDir：日志文件目录# Zookeeper保存日志文件的目录。dataLogDir&#x3D;&#x2F;data&#x2F;soft&#x2F;zookeeper-3.4.12&#x2F;logs# the port at which the clients will connect# clientPort：客户端连接端口# 客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。clientPort&#x3D;2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns&#x3D;60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount&#x3D;3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval&#x3D;1# 服务器名称与地址：集群信息（服务器编号，服务器地址，LF通信端口，选举端口）# 这个配置项的书写格式比较特殊，规则如下：# server.N&#x3D;YYY:A:B# 其中N表示服务器编号，YYY表示服务器的IP地址，A为LF通信端口，表示该服务器与集群中的leader交换的信息的端口。B为选举端口，表示选举新leader时服务器间相互通信的端口（当leader挂掉时，其余服务器会相互通信，选择出新的leader）。一般来说，集群中每个服务器的A端口都是一样，每个服务器的B端口也是一样。但是当所采用的为伪集群时，IP地址都一样，只能时A端口和B端口不一样。\n\n\n\n可以不修改 zoo.cfg，使用默认配置。接下来在解压后的 bin/ 目录中执行命令 ./zkCli.sh -server 127.0.0.1:2181 就能进行连接了。\nWelcome to ZooKeeper!2020-06-01 15:03:52,512 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@1025] - Opening socket connection to server localhost&#x2F;127.0.0.1:2181. Will not attempt to authenticate using SASL (unknown error)JLine support is enabled2020-06-01 15:03:52,576 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@879] - Socket connection established to localhost&#x2F;127.0.0.1:2181, initiating session2020-06-01 15:03:52,599 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@1299] - Session establishment complete on server localhost&#x2F;127.0.0.1:2181, sessionid &#x3D; 0x100001140080000, negotiated timeout &#x3D; 30000WATCHER::WatchedEvent state:SyncConnected type:None path:null[zk: 127.0.0.1:2181(CONNECTED) 0]\n\n\n\n接下来可以使用命令查看节点：\n\n使用 ls 命令查看当前 ZooKeeper 中所包含的内容。命令：ls /\n\n[zk: 127.0.0.1:2181(CONNECTED) 10] ls &#x2F;[zookeeper]\n\n\n\n\n创建了一个新的 znode 节点 zk 以及与它关联的字符串。命令：create /zk myData\n\n[zk: 127.0.0.1:2181(CONNECTED) 11] create &#x2F;zk myDataCreated &#x2F;zk[zk: 127.0.0.1:2181(CONNECTED) 12] ls &#x2F;[zk, zookeeper][zk: 127.0.0.1:2181(CONNECTED) 13]\n\n\n\n\n获取 znode 节点 zk。命令：get /zk\n\n[zk: 127.0.0.1:2181(CONNECTED) 13] get &#x2F;zkmyDatacZxid &#x3D; 0x400000008ctime &#x3D; Mon Jun 01 15:07:50 CST 2020mZxid &#x3D; 0x400000008mtime &#x3D; Mon Jun 01 15:07:50 CST 2020pZxid &#x3D; 0x400000008cversion &#x3D; 0dataVersion &#x3D; 0aclVersion &#x3D; 0ephemeralOwner &#x3D; 0x0dataLength &#x3D; 6numChildren &#x3D; 0\n\n\n\n\n删除 znode 节点 zk。命令：delete /zk\n\n[zk: 127.0.0.1:2181(CONNECTED) 14] delete &#x2F;zk[zk: 127.0.0.1:2181(CONNECTED) 15] ls &#x2F;[zookeeper]\n\n\n\n\n\n由于篇幅有限，在接下来的文章中会根据上面提到的 ZooKeeper 应用场景逐一进行用代码进行实现。\n大家可以直接从 GitHub 拉取项目，启动只需要两步：\n\n从 GitHub 上面拉取项目。\n在 ZooKeeper 文件夹中执行 docker-compose up 命令。\n\nGitHub：github.com/modouxiansheng/about-docker/tree/master/ZooKeeper\n","categories":["zookeeper"],"tags":["zookeeper"]},{"title":"Redis","url":"https://12yuan.github.io/2020/12/03/Redis 的 8 大数据类型/","content":"[TOC]\nRedis 的八大数据类型官网可查看命令：http://www.redis.cn/commands.html\nRedis-key127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; set name xxxOK127.0.0.1:6379&gt; keys *1) &quot;name&quot;127.0.0.1:6379&gt; set age 1OK127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; exists name  # 判断key 是否存在(integer) 1127.0.0.1:6379&gt; exists name1(integer) 0127.0.0.1:6379&gt; move name 1(integer) 1127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; set name yyyOK127.0.0.1:6379&gt; expire name 10  # 设置key的过期时间，单位是秒(integer) 1127.0.0.1:6379&gt; ttl name  # 查看当前key的剩余过期时间(integer) 7127.0.0.1:6379&gt; ttl name(integer) -2127.0.0.1:6379&gt; type age  # 查看当前key的类型string127.0.0.1:6379&gt;\n\nRedis 有以下 8 种数据类型\n1、String（字符串）127.0.0.1:6379&gt; set key1 v1   #设置值OK127.0.0.1:6379&gt; get key1&quot;v1&quot;127.0.0.1:6379&gt; append key1 &quot;hello&quot;  # 追加值，如果不存在，相当于 set key(integer) 7127.0.0.1:6379&gt; get key1&quot;v1hello&quot;127.0.0.1:6379&gt; strlen key1  # 获取字符串长度(integer) 7127.0.0.1:6379&gt;\n\n自增、自减\n127.0.0.1:6379&gt; set views 0OK127.0.0.1:6379&gt; get views&quot;0&quot;127.0.0.1:6379&gt; incr views  # 自增 1(integer) 1127.0.0.1:6379&gt; get views&quot;1&quot;127.0.0.1:6379&gt; decr views       # 自减 1(integer) 0127.0.0.1:6379&gt; decr views(integer) -1127.0.0.1:6379&gt; get views&quot;-1&quot;127.0.0.1:6379&gt; incrby views 10  # 设置步长、自增 10 (integer) 9127.0.0.1:6379&gt; decrby views 5      # 设置步长、自减 5(integer) 4\n\n字符串范围\n127.0.0.1:6379&gt; set key1 &quot;hello,world!&quot;OK127.0.0.1:6379&gt; get key1&quot;hello,world!&quot;127.0.0.1:6379&gt; getrange key1 0 3  # 截取字符串\\[0, 3\\]&quot;hell&quot;127.0.0.1:6379&gt; getrange key1 0 -1  # 获取全部的字符串，和 get key一样&quot;hello,world!&quot;127.0.0.1:6379&gt;\n\n替换：\n127.0.0.1:6379&gt; set key2 abcdefgOK127.0.0.1:6379&gt; get key2&quot;abcdefg&quot;127.0.0.1:6379&gt; setrange key2 1 xx(integer) 7127.0.0.1:6379&gt; get key2&quot;axxdefg&quot;127.0.0.1:6379&gt;\n\nsetex(set with expire)：设置过期时间\n和setnx(set if not exist)：不存在再设置（在分布式锁中会经常使用）\n127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot;  # 设置 30 秒后过期OK127.0.0.1:6379&gt; ttl key3     # 剩余过期时间(integer) 25127.0.0.1:6379&gt; setnx mykey &quot;redis&quot;   # mykey 不存在时设置成功(integer) 1127.0.0.1:6379&gt; keys *1) &quot;key2&quot;2) &quot;key1&quot;3) &quot;views&quot;4) &quot;mykey&quot;127.0.0.1:6379&gt; setnx mykey &quot;mongoDB&quot;  # mykey 存在时设置失败(integer) 0127.0.0.1:6379&gt; get mykey     # mykey 值不变&quot;redis&quot;127.0.0.1:6379&gt;mset&#96; 和 &#96;mget127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3  # 同时设置多个值OK127.0.0.1:6379&gt; keys *1) &quot;k1&quot;2) &quot;k3&quot;3) &quot;k2&quot;127.0.0.1:6379&gt; mget k1 k2 k3   # 同时获取多个值1) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;127.0.0.1:6379&gt; msetnx k1 v1 k4 v4       # msetnx 是一个原子性的操作，要么一起成功，要么都失败(integer) 0127.0.0.1:6379&gt; get k4(nil)127.0.0.1:6379&gt;\n\n对象\nset user:1 &#123;name:zhangsan, age:3&#125;     # 设置一个 user:1 对象 值为 json  字符来保存一个对象127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379&gt; mget user:1:name user:1:age1) &quot;zhangsan&quot;2) &quot;2&quot;127.0.0.1:6379&gt;\n\ngetset：先 get 再 set\n127.0.0.1:6379&gt; getset db redis  # 如果不存在值，则返回 nil(nil)127.0.0.1:6379&gt; get db&quot;redis&quot;127.0.0.1:6379&gt; getset db mongodb  # 如果存在值，获取原来的值，并设置新的值&quot;redis&quot;127.0.0.1:6379&gt; get db&quot;mongodb&quot;127.0.0.1:6379&gt;\n\nString 的使用场景：value 除了是字符串以外还可以是数字\n\n计数器\n统计多单位的数量\n粉丝数\n对象缓存存储\n\n2、List（列表）基本的数据类型，列表。\n在 Redis 中可以把 list 用作栈、队列、阻塞队列。\nlist 命令多数以 l开头。\n127.0.0.1:6379&gt; lpush list one   # 将一个值或者多个值，插入到列表的头部（左）(integer) 1127.0.0.1:6379&gt; lpush list two(integer) 2127.0.0.1:6379&gt; lpush list three (integer) 3127.0.0.1:6379&gt; lrange list 0 -1   # 查看全部元素1) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; lrange list 0 1    # 通过区间获取值1) &quot;three&quot;2) &quot;two&quot;127.0.0.1:6379&gt; rpush list right   # 将一个值或者多个值，插入到列表的尾部（右）(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;right&quot;127.0.0.1:6379&gt;\n\n弹出 pop\n127.0.0.1:6379&gt; lrange list 0 -11) &quot;!&quot;2) &quot;world&quot;3) &quot;world&quot;4) &quot;hello&quot;127.0.0.1:6379&gt; lpop list  # 移除list的第一个元素&quot;!&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;world&quot;2) &quot;world&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; rpop list   # 移除list的第一个元素&quot;hello&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;world&quot;2) &quot;world&quot;127.0.0.1:6379&gt;\n\n索引 Lindex\n127.0.0.1:6379&gt; lrange list 0 -11) &quot;hjk&quot;2) &quot;world&quot;3) &quot;world&quot;127.0.0.1:6379&gt; lindex list 1  # 通过下标获取list中的某一个值&quot;world&quot;127.0.0.1:6379&gt; lindex list 0&quot;hjk&quot;127.0.0.1:6379&gt;\n\nLlen 长度：\n127.0.0.1:6379&gt; llen list(integer) 3127.0.0.1:6379&gt;\n\n移除指定的值：\n127.0.0.1:6379&gt; lrange list 0 -11) &quot;hjk&quot;2) &quot;world&quot;3) &quot;world&quot;127.0.0.1:6379&gt; lrem list 1 world  # 移除list集合中指定个数的value，精确匹配(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) &quot;hjk&quot;2) &quot;world&quot;127.0.0.1:6379&gt; lpush list hjk(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;hjk&quot;2) &quot;hjk&quot;3) &quot;world&quot;127.0.0.1:6379&gt; lrem list 2 hjk(integer) 2127.0.0.1:6379&gt; lrange list 0 -11) &quot;world&quot;127.0.0.1:6379&gt;\n\ntrim 截断\n127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello1&quot;2) &quot;hello2&quot;3) &quot;hello3&quot;4) &quot;hello4&quot;127.0.0.1:6379&gt; ltrim mylist 1 2 # 通过下标截取指定长度，这个list已经被破坏了，截断之后只剩下截断后的元素OK127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello2&quot;2) &quot;hello3&quot;127.0.0.1:6379&gt;\n\nrpoplpush ：移除列表的最后一个元素，将他移动到新的列表中。\n127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello1&quot;2) &quot;hello2&quot;3) &quot;hello3&quot;127.0.0.1:6379&gt; rpoplpush mylist myotherlist  # 移除列表的最后一个元素，将他移动到新的列表中。&quot;hello3&quot;127.0.0.1:6379&gt; lrange mylist 0 -1  # 查看原来的列表1) &quot;hello1&quot;2) &quot;hello2&quot;127.0.0.1:6379&gt; lrange myotherlist 0 -1  # 查看目标列表中，确实存在该值1) &quot;hello3&quot;127.0.0.1:6379&gt;\n\nlset：将列表中指定下标的值替换为另一个值，更新操作\n127.0.0.1:6379&gt; exists list  # 判断这个列表是否存在(integer) 0127.0.0.1:6379&gt; lset list 0 item  # 如果不存在的话，更新会报错(error) ERR no such key127.0.0.1:6379&gt; lpush list value1(integer) 1127.0.0.1:6379&gt; lrange list 0 0 1) &quot;value1&quot;127.0.0.1:6379&gt; lset list 0 item  # 如果存在，更新当前下标的值OK127.0.0.1:6379&gt; lset list 1 other  # 如果不存在的话，更新会报错(error) ERR index out of range127.0.0.1:6379&gt;\n\nlinsert：将某个具体的value插入到列表中某个元素的前面或者后面\n127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello1&quot;2) &quot;hello2&quot;127.0.0.1:6379&gt; linsert mylist before &quot;hello2&quot; hello(integer) 3127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello1&quot;2) &quot;hello&quot;3) &quot;hello2&quot;127.0.0.1:6379&gt; linsert mylist after &quot;hello2&quot; hello(integer) 4127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello1&quot;2) &quot;hello&quot;3) &quot;hello2&quot;4) &quot;hello&quot;127.0.0.1:6379&gt;\n\n小结：\n\nlist 实际上是一个链表，前后都可以插入\n如果key不存在，创建新的链表\n如果移除了所有的值，空链表，也代表不存在\n在两边插入或者改动值，效率最高。\n\n3、Set （集合）127.0.0.1:6379&gt; sadd myset &quot;hello&quot;  # set 集合中添加元素(integer) 1127.0.0.1:6379&gt; sadd myset &quot;world&quot;(integer) 1127.0.0.1:6379&gt; smembers myset      # 查看指定Set的所有值1) &quot;world&quot;2) &quot;hello&quot;127.0.0.1:6379&gt; sismember myset hello  # 判断某一个值是不是在set中(integer) 1127.0.0.1:6379&gt; sismember myset hello1(integer) 0127.0.0.1:6379&gt;127.0.0.1:6379&gt; scard myset  # 获取集合中的个数(integer) 2127.0.0.1:6379&gt; sadd myset &quot;hello2&quot;(integer) 1127.0.0.1:6379&gt; smembers myset   1) &quot;world&quot;2) &quot;hello2&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; srem myset hello   # 移除元素(integer) 1127.0.0.1:6379&gt; smembers myset1) &quot;world&quot;2) &quot;hello2&quot;127.0.0.1:6379&gt;127.0.0.1:6379&gt; smembers myset1) &quot;kkk&quot;2) &quot;world&quot;3) &quot;hjk&quot;4) &quot;hello2&quot;127.0.0.1:6379&gt; srandmember myset   # 随机抽取一个元素&quot;hjk&quot;127.0.0.1:6379&gt; srandmember myset&quot;hello2&quot;127.0.0.1:6379&gt; srandmember myset 2   # 随机抽取指定个数的元素1) &quot;world&quot;2) &quot;hello2&quot;127.0.0.1:6379&gt; srandmember myset 21) &quot;hello2&quot;2) &quot;hjk&quot;127.0.0.1:6379&gt;127.0.0.1:6379&gt; smembers myset1) &quot;kkk&quot;2) &quot;world&quot;3) &quot;hjk&quot;4) &quot;hello2&quot;127.0.0.1:6379&gt; spop myset  # 随机删除元素&quot;hjk&quot;127.0.0.1:6379&gt; smembers myset1) &quot;kkk&quot;2) &quot;world&quot;3) &quot;hello2&quot;127.0.0.1:6379&gt; spop myset&quot;hello2&quot;127.0.0.1:6379&gt; smembers myset1) &quot;kkk&quot;2) &quot;world&quot;127.0.0.1:6379&gt;127.0.0.1:6379&gt; smembers myset1) &quot;kkk&quot;2) &quot;world&quot;127.0.0.1:6379&gt; sadd myset2 set2(integer) 1127.0.0.1:6379&gt; smove myset myset2 &quot;kkk&quot;   # 将一个特定的值，移动到另一个set集合中(integer) 1127.0.0.1:6379&gt; smembers myset1) &quot;world&quot;127.0.0.1:6379&gt; smembers myset21) &quot;kkk&quot;2) &quot;set2&quot;127.0.0.1:6379&gt;127.0.0.1:6379&gt; smembers key11) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;127.0.0.1:6379&gt; smembers key21) &quot;e&quot;2) &quot;d&quot;3) &quot;c&quot;127.0.0.1:6379&gt; sdiff key1 key2   # 差集1) &quot;b&quot;2) &quot;a&quot;127.0.0.1:6379&gt; sinter key1 key2         # 交集1) &quot;c&quot;127.0.0.1:6379&gt; sunion key1 key2  # 并集1) &quot;e&quot;2) &quot;a&quot;3) &quot;c&quot;4) &quot;d&quot;5) &quot;b&quot;\n\n4、Hash(哈希)也是 key - value 形式的，但是value 是一个map。\n127.0.0.1:6379&gt; hset myhash field xxx  # set 一个 key-value(integer) 1127.0.0.1:6379&gt; hget myhash field   # 获取一个字段值&quot;xxx&quot;127.0.0.1:6379&gt; hmset myhash field1 hello field2 world  # set 多个 key-valueOK127.0.0.1:6379&gt; hmget myhash field field1 field2   # 获取多个字段值1) &quot;xxx&quot;2) &quot;hello&quot;3) &quot;world&quot;127.0.0.1:6379&gt; hgetall myhash    # 获取全部的数据1) &quot;field&quot;2) &quot;xxx&quot;3) &quot;field1&quot;4) &quot;hello&quot;5) &quot;field2&quot;6) &quot;world&quot;127.0.0.1:6379&gt; hdel myhash field1  # 删除指定的key，对应的value也就没有了(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field&quot;2) &quot;xxx&quot;3) &quot;field2&quot;4) &quot;world&quot;127.0.0.1:6379&gt;127.0.0.1:6379&gt; hlen myhash  # 获取长度(integer) 2127.0.0.1:6379&gt; hexists myhash field1   # 判断指定key是否存在(integer) 0127.0.0.1:6379&gt; hexists myhash field2(integer) 1127.0.0.1:6379&gt; hkeys myhash  # 获取所有的key1) &quot;field&quot;2) &quot;field2&quot;127.0.0.1:6379&gt; hvals myhash  # 获取所有的value1) &quot;xxx&quot;2) &quot;world&quot;127.0.0.1:6379&gt;127.0.0.1:6379&gt; hset myhash field3 5(integer) 1127.0.0.1:6379&gt; hincrby myhash field3 1  # 指定增量(integer) 6127.0.0.1:6379&gt; hincrby myhash field3 -1(integer) 5127.0.0.1:6379&gt; hsetnx myhash field4 hello  # 如果不存在则可以设置(integer) 1127.0.0.1:6379&gt; hsetnx myhash field4 world  # 如果存在则不能设置(integer) 0127.0.0.1:6379&gt;\n\nHash 适合存储经常变动的对象信息，String 更适合于存储字符串。关注公众号Java技术栈，回复 Redis，可以获取我整理的 Redis 系列教程。\n5、zset (有序集合)127.0.0.1:6379&gt; zadd myset 1 one  # 添加一个值(integer) 1127.0.0.1:6379&gt; zadd myset 2 two 3 three # 添加多个值(integer) 2127.0.0.1:6379&gt; zrange myset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;127.0.0.1:6379&gt;\n\n实现排序：\n127.0.0.1:6379&gt; zadd salary 2500 xiaohong(integer) 1127.0.0.1:6379&gt; zadd salary 5000 xiaoming(integer) 1127.0.0.1:6379&gt; zadd salary 500 xaiozhang(integer) 1127.0.0.1:6379&gt; zrange salary 0 -11) &quot;xaiozhang&quot;2) &quot;xiaohong&quot;3) &quot;xiaoming&quot;127.0.0.1:6379&gt; zrangebyscore salary -inf +inf  # 从小到大显示全部的用户1) &quot;xaiozhang&quot;2) &quot;xiaohong&quot;3) &quot;xiaoming&quot;127.0.0.1:6379&gt; zrevrange salary 0 -1  # 从大到小进行排序1) &quot;xiaoming&quot;2) &quot;xiaohong&quot;3) &quot;xaiozhang&quot;127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores   # 附带成绩的显示所有用户1) &quot;xaiozhang&quot;2) &quot;500&quot;3) &quot;xiaohong&quot;4) &quot;2500&quot;5) &quot;xiaoming&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; zrangebyscore salary -inf 2500 withscores   # 显示工资小于 2500 的用户1) &quot;xaiozhang&quot;2) &quot;500&quot;3) &quot;xiaohong&quot;4) &quot;2500&quot;127.0.0.1:6379&gt; zrange salary 0 -11) &quot;xaiozhang&quot;2) &quot;xiaohong&quot;3) &quot;xiaoming&quot;127.0.0.1:6379&gt; zrem salary xiaohong  # 移除特定元素(integer) 1127.0.0.1:6379&gt; zrange salary 0 -11) &quot;xaiozhang&quot;2) &quot;xiaoming&quot;127.0.0.1:6379&gt; zcard salary  # 获取有序集合的个数(integer) 2127.0.0.1:6379&gt;127.0.0.1:6379&gt; zadd myset 1 hello(integer) 1127.0.0.1:6379&gt; zadd myset 2 world 3 !(integer) 2127.0.0.1:6379&gt; zcount myset 1 3  # 获取指定区间的人员数量(integer) 3127.0.0.1:6379&gt; zcount myset 1 2(integer) 2\n\n6、geospatialRedis 在 3.2 推出 Geo 类型，该功能可以推算出地理位置信息，两地之间的距离。\n文档：https://www.redis.net.cn/order/3687.html\n借助网站模拟一些数据：http://www.jsons.cn/lngcode/\n\ngeoadd 添加地理位置\n\n规则：两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。\n有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。当坐标位置超出指定范围时，该命令将会返回一个错误。\n(error) ERR invalid longitude latitude pair xxx yyy\n\n添加一些模拟数据：\n127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai(integer) 1127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shengzhen(integer) 2127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian(integer) 2127.0.0.1:6379&gt;\n\n\ngeopos 获得当前定位坐标值\n\n127.0.0.1:6379&gt; geopos china:city beijing  # 获得指定城市的经纬度1) 1) &quot;116.39999896287918091&quot;   2) &quot;39.90000009167092543&quot;127.0.0.1:6379&gt; geopos china:city shanghai1) 1) &quot;121.47000163793563843&quot;   2) &quot;31.22999903975783553&quot;127.0.0.1:6379&gt;\n\n\ngeodist 获取两个位置之间的距离\n\n单位：\n\nm 表示单位为米。\nkm 表示单位为千米。\nmi 表示单位为英里。\nft 表示单位为英尺。\n\n如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。\n127.0.0.1:6379&gt; geodist china:city beijing shanghai km # 查看北京和上海直接的直线距离&quot;1067.3788&quot;127.0.0.1:6379&gt; geodist china:city beijing chongqing km&quot;1464.0708&quot;127.0.0.1:6379&gt;\n\n\ngeoredius 以给定的经纬度为中心，找出某一半径内的元素\n\n127.0.0.1:6379&gt; georadius china:city 110 30 1000 km # 以110, 30 这个点为中心，寻找方圆 1000km 的城市1) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;127.0.0.1:6379&gt; georadius china:city 110 30 500 km 1) &quot;chongqing&quot;2) &quot;xian&quot;127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord #  显示他人的定位信息1) 1) &quot;chongqing&quot;   2) 1) &quot;106.49999767541885376&quot;      2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot;   2) 1) &quot;108.96000176668167114&quot;      2) &quot;34.25999964418929977&quot;127.0.0.1:6379&gt; 127.0.0.1:6379&gt; georadius china:city 110 30 500 km withdist #  显示到中心点的距离1) 1) &quot;chongqing&quot;   2) &quot;341.9374&quot;2) 1) &quot;xian&quot;   2) &quot;483.8340&quot;127.0.0.1:6379&gt; georadius china:city 110 30 500 km withdist withcoord count 1  # 指定数量1) 1) &quot;chongqing&quot;   2) &quot;341.9374&quot;   3) 1) &quot;106.49999767541885376&quot;      2) &quot;29.52999957900659211&quot;127.0.0.1:6379&gt; georadius china:city 110 30 500 km withdist withcoord count 21) 1) &quot;chongqing&quot;   2) &quot;341.9374&quot;   3) 1) &quot;106.49999767541885376&quot;      2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot;   2) &quot;483.8340&quot;   3) 1) &quot;108.96000176668167114&quot;      2) &quot;34.25999964418929977&quot;127.0.0.1:6379&gt;\n\n\nGEORADIUSBYMEMBER 找出位于指定元素周围的其他元素\n\n127.0.0.1:6379&gt; georadiusbymember china:city shanghai 1000 km1) &quot;hangzhou&quot;2) &quot;shanghai&quot;127.0.0.1:6379&gt;\n\n\ngeo 底层实现原理其实就是 zset ，可以使用 zset 命令操作 geo\n\n127.0.0.1:6379&gt; zrange china:city 0 -11) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;6) &quot;beijing&quot;127.0.0.1:6379&gt; zrem china:city beijing  # 删除一个元素(integer) 1127.0.0.1:6379&gt; zrange china:city 0 -11) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;127.0.0.1:6379&gt;\n\n7、hyperloglog基数：数学上集合的元素个数，是不能重复的。\nUV（Unique visitor）：是指通过互联网访问、浏览这个网页的自然人。访问的一个电脑客户端为一个访客，一天内同一个访客仅被计算一次。\nRedis 2.8.9 版本更新了 hyperloglog 数据结构，是基于基数统计的算法。\nhyperloglog 的优点是占用内存小，并且是固定的。存储 2^64 个不同元素的基数，只需要 12 KB 的空间。但是也可能有 0.81% 的错误率。\n这个数据结构常用于统计网站的 UV。传统的方式是使用 set 保存用户的ID，然后统计 set 中元素的数量作为判断标准。\n但是这种方式保存了大量的用户 ID，ID 一般比较长，占空间，还很麻烦。我们的目的是计数，不是保存数据，所以这样做有弊端。但是如果使用 hyperloglog 就比较合适了。\n127.0.0.1:6379&gt; pfadd mykey a b c d e f g h i j # 创建第一组元素(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey     # 统计 mykey 基数(integer) 10127.0.0.1:6379&gt; PFADD mykey2 i j z x c v b n m  # 创建第二组元素(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey2     # 统计 mykey2 基数(integer) 9127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2  # 合并两组 mykey mykey2 &#x3D;&gt; mykey3OK127.0.0.1:6379&gt; PFCOUNT mykey3(integer) 15127.0.0.1:6379&gt;\n\n8、bitmap 位图bitmap就是通过最小的单位bit来进行0或者1的设置，表示某个元素对应的值或者状态。一个bit的值，或者是0，或者是1；也就是说一个bit能存储的最多信息是2。\nbitmap 常用于统计用户信息比如活跃粉丝和不活跃粉丝、登录和未登录、是否打卡等。\n这里使用一周打卡的案例说明其用法：\n127.0.0.1:6379&gt; setbit sign 0 1  # 周一打卡了(integer) 0127.0.0.1:6379&gt; setbit sign 1 0  # 周二未打卡(integer) 0127.0.0.1:6379&gt; setbit sign 2 0  # 周三未打卡(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 4 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 1(integer) 0127.0.0.1:6379&gt; setbit sign 6 0(integer) 0127.0.0.1:6379&gt;\n\n查看某一天是否打卡：\n127.0.0.1:6379&gt; GETBIT sign 3(integer) 1127.0.0.1:6379&gt; GETBIT sign 6(integer) 0127.0.0.1:6379&gt;\n\n统计：统计打卡的天数\n127.0.0.1:6379&gt; BITCOUNT sign(integer) 4127.0.0.1:6379&gt;","categories":["Redis"],"tags":["Redis","数据类型"]},{"title":"弄懂nginx","url":"https://12yuan.github.io/2020/12/02/搞懂Nginx/","content":"[TOC]\n1.Nginx知识网结构图\nNginx是一个高性能的HTTP和反向代理服务器，特点是占用内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好\nnginx专为性能优化而开发，性能是其最重要的要求，十分注重效率，有报告nginx能支持高达50000个并发连接数\n1.1反向代理正向代理正向代理：局域网中的电脑用户想要直接访问网络是不可行的，只能通过代理服务器来访问，这种代理服务就被称为正向代理。\n\n反向代理反向代理：客户端无法感知代理，因为客户端访问网络不需要配置，只要把请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据，然后再返回到客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址\n\n1.2负载均衡客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行狡猾，服务器处理完毕之后，再将结果返回给客户端\n普通请求和响应过程\n\n但是随着信息数量增长，访问量和数据量飞速增长，普通架构无法满足现在的需求\n我们首先想到的是升级服务器配置，可以由于摩尔定律的日益失效，单纯从硬件提升性能已经逐渐不可取了，怎么解决这种需求呢？\n我们可以增加服务器的数量，构建集群，将请求分发到各个服务器上，将原来请求集中到单个服务器的情况改为请求分发到多个服务器，也就是我们说的负载均衡\n\n假设有15个请求发送到代理服务器，那么由代理服务器根据服务器数量，平均分配，每个服务器处理5个请求，这个过程就叫做负载均衡\n1.3动静分离为了加快网站的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析的速度，降低由单个服务器的压力\n动静分离之前的状态\n动静分离之后\n\n2. nginx如何在linux安装第一种linux系统CentOS 7 64位\n下载以下安装包，用xftp放入linux系统\n\n第一步：安装pcre依赖\n\n解压压缩文件，进入解压之后的目录执行./configure，然后执行make &amp;&amp; make install\n\n\n查看是否安装成功\n[root@localhost pcre-8.37]# pcre-config --version\n\n\n\n第二步：安装其他依赖\n[root@localhost pcre-8.37]# yum -y make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n\n\n第三步：安装nginx\n\n解压nginx，进入nginx目录\n执行make &amp;&amp; make install\n去sbin文件夹下启动nginx\n\ncd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin\n\n检查是否启动成功\n[root@localhost sbin]# ps -ef|grep nginx\n\n\n第二种linux系统Red Hat Enterprise Linux Server release 6.5 (Santiago)\n提前需要准备的1.nginx 源码 ： http://nginx.org/en/download.html2.yum安装教程：https://blog.csdn.net/yujing1314/article/details/972376443.gcc-c++\n[root@localhost ~]yum install gcc-c++\n\n4.第三方开发包\n[root@localhost ~]yum install -y pcre pcre-devel[root@localhost ~]yum install -y zlib zlib-devel[root@localhost ~]yum install -y openssl openssl-devel\n\n安装步骤第一步：把nginx的源码包上传到linux系统我使用的SecureCRT的sftp文件传输，直接把文件拖进去就OK了\n第二步：解压缩[root@localhost ~]tar zxf nginx-1.8.0.tar.gz\n\n第三步：使用configure命令创建一makeFile文件。.&#x2F;configure–prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx–pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid–lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx.lock–error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log–http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log–with-http_gzip_static_module–http-client-body-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client–http-proxy-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;proxy–http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;fastcgi–http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;uwsgi–http-scgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;scgi\n\n第四步 上一步可能会报错，因为缺少temp文件，如下创建即可[root@localhost sbin]# mkdir &#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client -p\n\n\n\n第五步 make直接输入 make\n第六步 make install直接输入 make install\n开启nginx[root@localhost sbin]# .&#x2F;nginx\n\n如何查看进程\n[root@bogon stefan]# ps aux|grep nginx\n\n关闭nginx：\n[root@localhost sbin]# .&#x2F;nginx -s stop\n\n推荐使用：\n[root@localhost sbin]# .&#x2F;nginx -s quit\n\n测试输入你虚拟机的ip，如下图就成功了\n\n如果测试失败，注意查看虚拟机防火墙是否关闭\n3. nginx常用命令查看版本\n.&#x2F;nginx -v\n\n启动\n.&#x2F;nginx\n\n关闭（有两种方式，推荐使用 ./nginx -s quit）\n.&#x2F;nginx -s stop .&#x2F;nginx -s quit\n\n重新加载nginx配置\n.&#x2F;nginx -s reload\n\n4.nginx的配置文件配置文件分三部分组成\n全局块 从配置文件开始到events块之间，主要是设置一些影响nginx服务器整体运行的配置指令\n并发处理服务的配置，值越大，可以支持的并发处理量越多，但是会受到硬件、软件等设备的制约\n\nevents块 影响nginx服务器与用户的网络连接，常用的设置包括是否开启对多workprocess下的网络连接进行序列化，是否允许同时接收多个网络连接等等\n支持的最大连接数\n\nhttp块 诸如反向代理和负载均衡都在此配置\nlocation指令说明\n\n该语法用来匹配url，语法如下\nlocation[ &#x3D; | ~ | ~* | ^~] url&#123;&#125;\n\n\n\n\n\n\n=:用于不含正则表达式的url前，要求字符串与url严格匹配，匹配成功就停止向下搜索并处理请求\n~：用于表示url包含正则表达式，并且区分大小写。\n~*：用于表示url包含正则表达式，并且不区分大瞎写\n^~：用于不含正则表达式的url前，要求ngin服务器找到表示url和字符串匹配度最高的location后，立即使用此location处理请求，而不再匹配\n如果有url包含正则表达式，不需要有~开头标识\n\n4.1 反向代理实战配置反向代理目的：在浏览器地址栏输入地址www.123.com跳转linux系统tomcat主页面\n具体实现 先配置tomcat：因为比较简单，此处不再赘叙 并在windows访问\n\n具体流程\n\n修改之前\n\n配置\n\n再次访问\n\n反向代理2\n1.目标 访问http://192.168.25.132:9001/edu/ 直接跳转到192.168.25.132:8080 访问http://192.168.25.132:9001/vod/ 直接跳转到192.168.25.132:8081\n2.准备 配置两个tomcat，端口分别为8080和8081，都可以访问，端口修改配置文件即可。\n\n\n新建文件内容分别添加8080！！！和8081！！！\n\n\n响应如下\n\n\n3.具体配置\n\n重新加载nginx\n./nginx -s reload\n访问\n\n\n实现了同一个端口代理，通过edu和vod路径的切换显示不同的页面\n4.2 反向代理小结第一个例子：浏览器访问www.123.com，由host文件解析 出服务器ip地址\n192.168.25.132 www.123.com 然后默认访问80端口，而通过nginx监听80端口代理到本地的8080端口上，从而实现了访问www.123.com，最终转发到tomcat 8080上去\n第二个例子：访问http://192.168.25.132:9001/edu/ 直接跳转到192.168.25.132:8080 访问http://192.168.25.132:9001/vod/ 直接跳转到192.168.25.132:8081\n实际上就是通过nginx监听9001端口，然后通过正则表达式选择转发到8080还是8081的tomcat上去\n4.3 负载均衡实战1.修改nginx.conf\n\n2.重启nginx\n.&#x2F;nginx -s reload\n\n3.在8081的tomcat的webapps文件夹下新建edu文件夹和a.html文件，填写内容为8081！！！！\n4.在地址栏回车，就会分发到不同的tomcat服器上\n\n\n3.负载均衡方式\n\n轮询（默认）\n\nweight，代表权，权越高优先级越高\n\n\nfair，按后端服务器的响应时间来分配请求，相应时间短的优先分配\n\n\nip_hash,每个请求按照访问ip的hash结果分配，这样每一个访客固定的访问一个后端服务器，可以解决session 的问题\n\n\n\n4.4 动静分离实战什么是动静分离把动态请求和静态请求分开，不是讲动态页面和静态页面物理分离，可以理解为nginx处理静态页面，tomcat处理动态页面\n动静分离大致分为两种：一、纯粹将静态文件独立成单独域名放在独立的服务器上，也是目前主流方案；二、将动态跟静态文件混合在一起发布，通过nginx分开\n动静分离图析\n\n实战准备准备静态文件\n\n\n配置nginx\n\n5.nginx高可用如果nginx出现问题解决办法前期准备\n\n两台nginx服务器\n安装keepalived\n虚拟ip\n\n5.1安装keepalived[root@192 usr]# yum install keepalived -y[root@192 usr]# rpm -q -a keepalivedkeepalived-1.3.5-16.el7.x86_64\n\n修改配置文件\n[root@192 keepalived]# cd &#x2F;etc&#x2F;keepalived[root@192 keepalived]# vi keepalived.conf \n\n分别将如下配置文件复制粘贴，覆盖掉keepalived.conf 虚拟ip为192.168.25.50\n\n对应主机ip需要修改的是 smtp_server 192.168.25.147（主）smtp_server 192.168.25.147（备） state MASTER（主） state BACKUP（备）\n\nglobal_defs &#123;   notification_email &#123;     acassen@firewall.loc     failover@firewall.loc     sysadmin@firewall.loc   &#125;   notification_email_from Alexandre.Cassen@firewall.loc   smtp_server 192.168.25.147   smtp_connect_timeout 30   router_id LVS_DEVEL # 访问的主机地址&#125;vrrp_script chk_nginx &#123;  script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;  # 检测文件的地址  interval 2   # 检测脚本执行的间隔  weight 2   # 权重&#125;vrrp_instance VI_1 &#123;    state BACKUP    # 主机MASTER、备机BACKUP        interface ens33   # 网卡    virtual_router_id 51 # 同一组需一致    priority 90  # 访问优先级，主机值较大，备机较小    advert_int 1    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    virtual_ipaddress &#123;        192.168.25.50  # 虚拟ip    &#125;&#125;\n\n启动\n[root@192 sbin]# systemctl start keepalived.service\n\n\n访问虚拟ip成功关闭主机147的nginx和keepalived，发现仍然可以访问\n6.原理解析如下图，就是启动了一个master，一个worker，master是管理员，worker是具体工作的进程worker如何工作\n小结\nworker数应该和CPU数相等\n一个master多个worker可以使用热部署，同时worker是独立的，一个挂了不会影响其他的\n\n","categories":["Linux"],"tags":["nginx"]},{"title":"hexo框架搭建个人博客","url":"https://12yuan.github.io/2020/11/26/hexo搭建个人博客/","content":"安装Node环境首先我们在本机要安装Node环境，我们可以直接来到Node.js官网：https://nodejs.org/en/，直接点击下图下载。![](https://cdn.jsdelivr.net/gh/12yuan/12yuan.github.io/image_file/20201126164325.png)\n下载后，直接双击，然后就是一直下一步下一步的傻瓜式操作。这里要注意的是：有的人的电脑可能已经安装好Node环境，已经安装好的可以通过在cmd窗口执行下面的命令查看Node版本：node  -v\n若是在Node版本为10以下的要更新一下自己的Node版本，因为Node10以下版本的执行安装hexo的时候会报错，并且它会明确的提示你版本不匹配的报错信息。\n安装完后，再次检验一下cmd窗口分别输入输入下面两条命令：\nnode -v\nnpm -v\n\n安装完Node环境后，就是安装Git，安装Git很简单，这里就直接略过了，在Git官网下载：https://git-scm.com/downloads，然后也是傻瓜式一步一步的操作。\n安装hexo首先，在自己的本地中新建一个文件夹用来存放hexo的代码，我这里就直接在E:\\Myhexo下进行安装hexo`。\n在E:\\Myhexo目录下，右击打开Git Bash，接着在Gir Bash中执行：npm install -g hexo命令，当看到下图所示表示安装完成，第一次可能等的时间会比较长：\n接着在执行：hexo init，初始化hexo项目，实际是从github中拉取项目：\n当hexo初始化完后，你就能看你当前目录下多出了很多有关hexo项目的文件：\n\n这些目录中，其中比较重要的文件和文件夹是：source和themes文件夹，以及_config.yml文件：\n\nsource：该文件夹是存放我们自己文章的地方，文章存放在该目录下的_posts文件夹中。\nthemes：用于存放博客的主题信息。\n_config.yml：是hexo博客的配置文件，很多配置信息都在这里面。\n\n接下来执行：npm install和hexo g，使用npm源安装所依赖的组件和编译生成静态页面。\n\n执行完上面的命令后，你会发现项目多了一个public文件夹，该文件夹就是用于存放静态页面的地方，该文件夹下的静态页面都是根据配置文件动态生成的，所以只要修改配置文件_config.yml中的配置信息，就可以使生成的静态页面发生改变：\n最后就是启动hexo，通过执行命令：hexo s，就会出现如下的页面：\n它已经明确的告诉你，访问本地4000端口，在浏览器输入：http://localhost:4000，若是出现了下面的页面说明本地搭建成功：\n我们现在能看到的就是hexo默认的主题，该主题信息存储在themes下的landscape文件夹中。\n若是想要修改这个默认主题，比如上面图片中大大的Hexo字体，我们要修改为我们自己的博客名称，首先打开MyBlog目录下的配置文件_config.yml：\n在这个配置文件有很多的配置信息，我们可以先找到title以及author这两个字段修改形成我们自己的信息。\n\n接着执行：hexo clean和hexo g，hexo clean：表示清除原来的缓存，它会直接把原来编译生成的静态文件夹public直接删除；hexo g：又会再次根据配置文件生成静态页面。\n最后，我们再次启动项目（hexo s），访问http://localhost:4000：\n我们Hello World的文章换成我们自己的文章，这个文章就是位于我们前面所讲的source/_posts文件夹下：\n我们只要把这个md替换成我们自己文章的md就可以了，然后再依次执行下面三条命令：\n\nhexo clean\nhexo g\nhexo s  \n\n这样就好看很多，另外要注意的是要想在上图的右边红色框内显示提交的主题，要在你的文章内加入标题，它就会自动识别：\n\n但是，还是感觉这个主题很丑，这时候就要用到hexo官方的主题库：https://hexo.io/themes/ ，在这里可以选择自己预览自己的主题库：\n这里我选择一个比较高大上（骚）的主题，点击红色框内就是预览该主题，点击蓝色框就会跳转到该主题的github源码地址。\n若是想要使用该主题，必须要把该主题下载下来，首先点击蓝色框进入该主题的github地址，复制该github地址，然后需要执行下面的命令：\ngit clone https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis.git themes&#x2F;volantis\n\n它表示把主题源码下载到themes主题文件夹下的volantis文件夹下。下载完后，要修改Myhexo目录下的配置文件_config.yml中的下面字段的配置：\n最后在执行hexo clean、hexo g和hexo s命令，就可以在浏览器看到效果：\n\n是不是感觉瞬间高大上，牛逼了很多，这样一个自己博客逼格就出来了，不需要自己写界面和后台，所以直接使用hexo来搭建个人技术博客还是非常方便的，基本的需求都能满足。\n此时。在本次部署好之后就可以将代码推向github仓库，但是在推向github之前，你的MyBlog文件夹必须与你的远程仓库相关联，这个关联的方法在这一篇[（一）深入浅出图解Git，入门到精通（保姆级教程）]已经讲过了，这里就不再做详细的赘述了，就是将你的本地的.ssh/id_rsa文件中的key复制到远程仓库中的SSH Keys。\n当你的本地仓库与远程仓库关联后，就在远程仓库创建一个如下图所示的仓库，仓库名必须是：**你的用户名+”.github.io”**：\n最后还要在Myhexo文件夹下的_config.yml`配置文件中配置如下的信息：\n这样子就可以使用下面四条命令，就可以将你本地的代码推向远程仓库了：\nnpm install hexo-deployer-git --savehexo cleanhexo generatehexo deploy\n\n最后在你的浏览器输入：http://+”你的用户名”+.github.io，就可以访问你自己的个人博客了，例如我个人的博客站点是：http://12yuan.github.io，最后的效果：\n到此，使用hexo框架搭建个人博客的教程就已经结束了，最后有一点要说明一下的是：除了Myhexo下的配置文件_config.yml文件可以修改，还有themes/volantis文件夹下的_config.yml配置文件也是可以修改的，这个可以自己去研究。\n然后每次修改完，也是执行下面四条命令：\nhexo cleanhexo ghexo shexo d\n\n我觉得主题信息可以选择比较简单的，因为都是基于配置信息进行配置的，假如太复杂的博客主题，你还要去它的github的源码地址中去研究它每一个配置字段的含义或者看他的注解，会花费大量的时间，我觉得没必要。\n经过多用户的访问测试显示，有的人手机无法访问，有的人手机可以访问，有的人电脑无法访问，有的人电脑可以访问，具体原因不太清楚，若是有人知道原因的，可以在评论区告诉我原因，不甚感激。\n最后说一句，你的面试官能不能看到你搭建的站点就得看命了，很可能访问不了，哈哈哈哈\n","categories":["me"],"tags":["其他"]},{"title":"Linux安装mysql（mysql-5.7.23-1.el7.x86_64.rpm-bundle.tar）（万能解决登录问题，最详细教程）","url":"https://12yuan.github.io/2020/11/20/Linux安装mysql/","content":"Linux安装mysql（mysql-5.7.23-1.el7.x86_64.rpm-bundle.tar）（万能解决登录问题，最详细教程）1.下载mysql\n官网地址：https://dev.mysql.com/downloads/mysql/5.7.html#downloads  \n注意事项：  1）下载的安装包必须是.rpm-bundle.tar结尾的  2）安装的时候，对应自己的下载版本号，不要直接复制命令  \n2.下载完成后，通过ftp上传到Linux服务器上  1）创建mysql5.7.23目录\n  [root@VM_0_16_centos ~]# mkdir mysql5.7.23\n  mysql5.7.23\n  2）将下载好的安装上传到该目录下\n  [root@VM_0_16_centos ~]# cd mysql5.7.23\n  [root@VM_0_16_centos mysql5.7.23]# ls\n  mysql-5.7.23-1.el7.x86_64.rpm-bundle.tar  \n3.解压安装包（mysql-5.7.23-1.el7.x86_64.rpm-bundle.tar）  [root@VM_0_16_centos mysql5.7.23]# tar xvf mysql-5.7.23-1.el7.x86_64.rpm-bundle.tar  mysql-community-common-5.7.23-1.el7.x86_64.rpm  mysql-community-libs-compat-5.7.23-1.el7.x86_64.rpm  mysql-community-minimal-debuginfo-5.7.23-1.el7.x86_64.rpm  mysql-community-server-5.7.23-1.el7.x86_64.rpm  mysql-community-devel-5.7.23-1.el7.x86_64.rpm  mysql-community-libs-5.7.23-1.el7.x86_64.rpm  mysql-community-client-5.7.23-1.el7.x86_64.rpm  mysql-community-server-minimal-5.7.23-1.el7.x86_64.rpm  mysql-community-test-5.7.23-1.el7.x86_64.rpm  mysql-community-embedded-devel-5.7.23-1.el7.x86_64.rpm  mysql-community-embedded-5.7.23-1.el7.x86_64.rpm  mysql-community-embedded-compat-5.7.23-1.el7.x86_64.rpm  [root@VM_0_16_centos mysql5.7.23]#  \n4.卸载掉centos7自带的mariadb-lib方法一：  1）查询mariadb信息\n  [root@VM_0_16_centos mysql5.7.23]# rpm -qa|grep mariadb\n  mariadb-libs-5.5.56-2.el7.x86_64\n  2）使用rpe -e命令卸载\n  [root@VM_0_16_centos mysql5.7.23]# rpm -e mariadb-libs-5.5.56-2.el7.x86_64 --nodeps  \n此方法卸载失败或者报错，请使用方法二方法二：\n\n使用yum remove 命名进行删除[root@VM_0_16_centos mysql5.7.23]# yum remove mysql-libs\n------------------------------------------------------------------------------------------------------------------------\n已加载插件：fastestmirror, langpacks\n正在解决依赖关系\n--&gt; 正在检查事务\n---&gt; 软件包 mariadb-libs.x86_64.1.5.5.44-2.el7.centos 将被 删除\n--&gt; 正在处理依赖关系 libmysqlclient.so.18()(64bit)，它被软件包 2:postfix-2.10.1-6.el7.x86_64 需要\n--&gt; 正在处理依赖关系 libmysqlclient.so.18(libmysqlclient_18)(64bit)，它被软件包 2:postfix-2.10.1-6.el7.x86_64 需要\n--&gt; 正在检查事务\n---&gt; 软件包 postfix.x86_64.2.2.10.1-6.el7 将被 删除\n--&gt; 解决依赖关系完成\nbase/7/x86_64                                                                                                   | 3.6 kB  00:00:00    \nextras/7/x86_64                                                                                                 | 3.4 kB  00:00:00    \nupdates/7/x86_64                                                                                                | 3.4 kB  00:00:00    \n依赖关系解决\n=======================================================================================================================================\nPackage                         架构                      版本                                     源                            大小\n=======================================================================================================================================\n正在删除:\nmariadb-libs                    x86_64                    1:5.5.44-2.el7.centos                    @anaconda                    4.4 M\n为依赖而移除:\npostfix                         x86_64                    2:2.10.1-6.el7                           @anaconda                     12 M\n事务概要\n=======================================================================================================================================\n移除  1 软件包 (+1 依赖软件包)\n安装大小：17 M\n是否继续？[y/N]：y\nDownloading packages:\nRunning transaction check\nRunning transaction test\nTransaction test succeeded\nRunning transaction\n警告：RPM 数据库已被非 yum 程序修改。\n** 发现 4 个已存在的 RPM 数据库问题， &#39;yum check&#39; 输出如下：\nicedtea-web-1.6.1-4.el7.x86_64 有缺少的需求 java-1.8.0-openjdk\njline-1.0-8.el7.noarch 有缺少的需求 java &gt;= (&#39;0&#39;, &#39;1.5&#39;, None)\n1:libreoffice-core-4.3.7.2-5.el7.x86_64 有缺少的需求 java-headless &gt;= (&#39;1&#39;, &#39;1.6&#39;, None)\n1:libreoffice-ure-4.3.7.2-5.el7.x86_64 有缺少的需求 libjvm.so()(64bit)\n正在删除    : 2:postfix-2.10.1-6.el7.x86_64                                                                                      1/2\n正在删除    : 1:mariadb-libs-5.5.44-2.el7.centos.x86_64                                                                          2/2\n验证中      : 1:mariadb-libs-5.5.44-2.el7.centos.x86_64                                                                          1/2\n验证中      : 2:postfix-2.10.1-6.el7.x86_64                                                                                      2/2\n删除:\nmariadb-libs.x86_64 1:5.5.44-2.el7.centos                                                                                           \n作为依赖被删除:\npostfix.x86_64 2:2.10.1-6.el7                                                                                                       \n完毕！  \n5.安装mysql-server服务，只需要安装如下4个软件包即可，使用rpm -ivh进行安装（按顺序安装，后面的服务依赖前面的服务）[root@VM_0_16_centos mysql5.7.23]# rpm -ivh mysql-community-common-5.7.23-1.el7.x86_64.rpm \n警告：mysql-community-common-5.7.23-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY\n准备中...                          ################################# [100%]\n正在升级/安装...\n1:mysql-community-common-5.7.23-1.e################################# [100%]\n[root@VM_0_16_centos mysql5.7.23]# rpm -ivh mysql-community-libs-5.7.23-1.el7.x86_64.rpm \n警告：mysql-community-libs-5.7.23-1.el7.x86_64.rpm: 头V3 DSA/SHA1   Signature, 密钥 ID 5072e1f5: NOKEY\n准备中...                          ################################# [100%]\n正在升级/安装...\n1:mysql-community-libs-5.7.23-1.el7################################# [100%]\n[root@VM_0_16_centos mysql5.7.23]# rpm -ivh mysql-community-client-5.7.23-1.el7.x86_64.rpm \n警告：mysql-community-client-5.7.23-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY\n准备中...                          ################################# [100%]\n正在升级/安装...\n1:mysql-community-client-5.7.23-1.e################################# [100%]\n[root@VM_0_16_centos mysql5.7.23]# rpm -ivh mysql-community-server-5.7.23-1.el7.x86_64.rpm \n警告：mysql-community-server-5.7.23-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY\n准备中...                          ################################# [100%]\n正在升级/安装...\n1:mysql-community-server-5.7.23-1.e################################# [100%]\n6.安装过程中可能出现的问题1).缺少libaio\n    [root@VM_0_16_centos mysql5.7.23]# rpm -ivh mysql-community-server-5.7.17-1.el7.x86_64.rpm \n    警告：mysql-community-server-5.7.17-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY\n    错误：依赖检测失败：\n        libaio.so.1()(64bit) 被 mysql-community-server-5.7.17-1.el7.x86_64 需要\n        libaio.so.1(LIBAIO_0.1)(64bit) 被 mysql-community-server-5.7.17-1.el7.x86_64 需要\n        libaio.so.1(LIBAIO_0.4)(64bit) 被 mysql-community-server-5.7.17-1.el7.x86_64 需要\n        net-tools 被 mysql-community-server-5.7.17-1.el7.x86_64 需要\n    解决办法：\n    [root@VM_0_16_centos mysql5.7.23]# yum install libaio  \n\n2)缺少net-tools\n    [root@VM_0_16_centos mysql5.7.23]# rpm -ivh mysql-community-server-5.7.17-1.el7.x86_64.rpm \n    警告：mysql-community-server-5.7.17-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY\n    错误：依赖检测失败：\n        net-tools 被 mysql-community-server-5.7.17-1.el7.x86_64 需要\n解决办法：\n\n    yum install net-tools\n3）缺少numactl\n    [root@VM_0_16_centos mysql5.7.23]# rpm -ivh mysql-community-server-5.7.17-1.el7.x86_64.rpm \n\n    报错：warning: mysql-community-server-5.7.9-1.el6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY\n    error: Failed dependencies:\n    libnuma.so.1()(64bit) is needed by mysql-community-server-5.7.9-1.el6.x86_64\n    libnuma.so.1(libnuma_1.1)(64bit) is needed by mysql-community-server-5.7.9-1.el6.x86_64\n    libnuma.so.1(libnuma_1.2)(64bit) is needed by mysql-community-server-5.7.9-1.el6.x86_64\n\n    解决办法：\n    yum  install numactl  \n7.初始化数据库[root@VM_0_16_centos mysql5.7.23]# mysqld --initialize  #初始化后会在/var/log/mysqld.log生成随机密码\n8.修改mysql数据库目录的所属用户及其所属组，然后启动mysql数据库[root@VM_0_16_centos mysql5.7.23]# chown mysql:mysql /var/lib/mysql -R\n[root@VM_0_16_centos mysql5.7.23]# systemctl start mysqld.service\n[root@VM_0_16_centos mysql5.7.23]# systemctl status mysqld.service\n● mysqld.service - MySQL Server\nLoaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)\nActive: active (running) since 一 2018-08-06 20:41:25 CST; 6s ago\n Docs: man:mysqld(8)\n       http://dev.mysql.com/doc/refman/en/using-systemd.html\nProcess: 13031 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS)\nProcess: 13003 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)\nMain PID: 13034 (mysqld)\n    Tasks: 27\nCGroup: /system.slice/mysqld.service\n       └─13034 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid\n\n8月 06 20:41:22 eric111 systemd[1]: Starting MySQL Server...\n8月 06 20:41:25 eric111 systemd[1]: Started MySQL Server.  \n9.登录mysql，并修改root用户的密码（系统强制要求，否则不能操作mysql）初始登录密码可在/var/log/mysqld.log文件中找到[root@VM_0_16_centos mysql5.7.23]# mysql -uroot -p&#39;-4iq&lt;tyjVpLb&#39;\nmysql: [Warning] Using a password on the command line interface can be insecure.\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 2\nServer version: 5.7.23\n\nCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\n\nmysql&gt; set password=password(&#39;123456&#39;);\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\nmysql&gt; flush privileges;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n4 rows in set (0.00 sec)  \n10.开启无密码登录模式（1）mysql的配置文件在etc目录下，默认是my.cnf\n\n    [root@localhost /]# cd etc\n    [root@localhost etc]# find my.cnf\n    my.cnf\n    [root@localhost etc]# ls\n    abrt                     crontab                  gcrypt       kernel                    mtab               printcap        scl             system-release\n    adjtime                  cron.weekly              gdbinit      krb5.conf                 my.cnf             profile         securetty       system-release-cpe\n    aliases                  crypttab                 gdbinit.d    ld.so.cache               my.cnf.d           profile.d       security        tcsd.conf\n\n    [root@localhost etc]# \n（2）编辑my.cnf文件，加入skip-grant-tables配置，开启无密码登录\n\n    打开my.cnf文件，输入如下命令，按回车\n\n    [root@localhost etc]# vim /etc/my.cnf\n    按insert键切换编辑模式，增加skip-grant-tables配置\n\n    # For advice on how to change settings please see\n    # http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html\n\n    [mysqld]\n    skip-grant-tables\n\n......省略...... \n\n（3）保存并退出，然后重启mysql服务\n\n    按esc键后，输入:wq   按回车键，保存退出，或者输入:wq!   按回车键，强制保存并退出\n\n    重启mysql服务\n\n    [root@localhost etc]# systemctl restart mysqld.service\n    [root@localhost etc]# \n（4）登录mysql\n\n    [root@localhost etc]# mysql\n    Welcome to the MySQL monitor.  Commands end with ; or \\g.\n    Your MySQL connection id is 2\n    Server version: 5.7.30 MySQL Community Server (GPL)\n\n    Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.\n\n    Oracle is a registered trademark of Oracle Corporation and/or its\n    affiliates. Other names may be trademarks of their respective\n    owners.\n\n    Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\n\n    mysql&gt; \n11.修改登录密码（1）使用mysql数据库\n\n    mysql&gt; use mysql;\n    Reading table information for completion of table and column names\n    You can turn off this feature to get a quicker startup with -A\n\n    Database changed\n    mysql&gt; \n（2）查看mysql当前用户信息\n\n    host字段是允许连接mysql服务的客户端主机，%代表所有客户端主机，localhost代表只能在当前主机访问，及本地访问\n\n    user字段是登录mysql的用户名称，当前默认有root、mysql.sys、mysql.session三个用户\n\n    authentication_string字段是登录mysql的用户密码，加密后的密码，该字段是mysql5.7版本开始使用，之前版本字段为password\n\n    mysql&gt; select host,user,authentication_string from user;\n    +-----------+---------------+-------------------------------------------+\n    | host      | user          | authentication_string                     |\n    +-----------+---------------+-------------------------------------------+\n    | %         | root          | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |\n    | localhost | mysql.session | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n    | localhost | mysql.sys     | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n    +-----------+---------------+-------------------------------------------+\n    3 rows in set (0.00 sec)\n\n    mysql&gt; \n（3）修改root用户的密码为123456，以及客户端主机访问限制，允许所有主机访问，修改完成，使用flush privileges;刷新权限\n\n    mysql&gt; update user set host=&#39;%&#39;,authentication_string=password(&#39;123456&#39;) where user=&#39;root&#39;;\n    Query OK, 0 rows affected, 1 warning (0.02 sec)\n    Rows matched: 1  Changed: 0  Warnings: 1\n\n    mysql&gt; flush privileges;\n    Query OK, 0 rows affected (0.01 sec)\n\n    mysql&gt; \n（4）修改密码中，可能出现的错误解决\n\n    错误信息：\n\nERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.\n解决方案：\n\nalter user &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39;;\n12.修改访问权限目的：任何主机通过用户root和密码123456连接到mysql服务器，并授权所有权限\n\nmysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\nmysql&gt; flush privileges;\nQuery OK, 0 rows affected (0.01 sec)\n13.取消无密码登录模式（1）注释或者删除/etc/my.cnf文件中的skip-grant-tables配置\n\n（2）重启mysql服务（systemctl restart mysqld.service）\n","categories":["Linux"],"tags":["jQuery","表格","表单验证"]},{"title":"centos8安装教程","url":"https://12yuan.github.io/2020/11/17/centos8安装教程/","content":"centos8 安装教程1、简介CentOS 8 官方正式发布了！CentOS 完全遵守 Red Hat 的再发行政策，并且致力与上游产品在功能上完全兼容。CentOS 对组件的修改主要是去除 Red Hat 的商标及美工图。该版本还包含全新的 RHEL upstream, CentOS Streams。\n\n官方中文的发行说明：https://wiki.centos.org/Manuals/ReleaseNotes/CentOS8.1905\n2、CentOS 8 的新特性\nDNF 成为了默认的软件包管理器，同时 yum 仍然是可用的\n使用网络管理器（nmcli和nmtui）进行网络配置，移除了网络脚本\n使用 Podman 进行容器管理\n\n\n引入了两个新的包仓库：BaseOS 和 AppStream\n使用 Cockpit 作为默认的系统管理工具\n默认使用 Wayland 作为显示服务器\niptables将被nftables取代\n使用 Linux 内核 4.18\n提供 PHP 7.2、Python 3.6、Ansible 2.8、VIM 8.0 和 Squid 4最低配置\n\n\n2 GB RAM\n64 位 x86 架构、2 GHz 或以上的 CPU\n20 GB 硬盘空间第一步：官网下载ISO文件\n\nhttps://mirrors.aliyun.com/centos/8.0.1905/isos/x86_64/CentOS-8-x86_64-1905-dvd1.iso\n阿里下载站，比较快一点，直接复制链接到迅雷就能下载了，大小约6.6Ghttp://mirrors.163.com/centos/8.0.1905/isos/x86_64/CentOS-8-x86_64-1905-dvd1.iso #网易下载站  \n","categories":[],"tags":[]},{"title":"Hello World","url":"https://12yuan.github.io/2020/11/16/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":[],"tags":[]}]